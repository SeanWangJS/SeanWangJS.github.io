## 编译原理：词法分析

举一个简单的例子，刚开始学习编程那会儿，在做数学运算的时候，总想把数学公式输入到程序里，然后自动计算。但是发现计算机并不能聪明地把公式字符串转换成可以计算的表达式。那是懵懂初开的年纪，觉得这是很简单的功能啊，为什么实现起来会毫无头绪。

后来的想法是一个字符一个字符地处理，然后写了很多复杂的分支逻辑，花了大量的时间和精力，却只实现了个简单到没什么用处的公式处理器。随着编程阅历的增加，才逐渐意识到这就是没有科学化，结构化地学习计算机基础知识的原因，就是没有学编译原理的锅。

从编译的角度来看，处理一段公式字符串，就是依据数学的语言约定来解析这段字符串的含义，然后生成可以运行的程序。这里所说的数学的语言约定就是所谓的文法，而解析字符串的含义则是语法分析。但是在做语法分析之前，或者说是为了更纯粹地进行语法分析，还需要对这一串字符进行分割。因为文法是以词为单位定义的，比如说一个数，或者一个函数名，而词通常包含了多个字符，源字符串显然并未给出词的任何信息，这就需要我们将其分解为一个一个的词，来供给语法分析器处理，这一分割过程就是词法分析。

当然进行词法分析也需要依据一定的模式集合，当遇到符合某一模式的子串时，则将其提取出来，也就是说通过这些规则可以识别源字符串中的词素。下面用一个具体的例子来说明，比如

$$
1.1*(2.1+\sin(\pi))
$$

在这个式子里面，1.1 是一个词素，$$\sin$$ 也是一个词素，这些都是数学语言定义的原子级别块，无法再细分，词法分析的任务就是从这样的串中分割出一个序列
$$
1.1,\,*\,,\,(\,,\,2.1\,,+\,,\sin,\,(\,,\pi ,\,),\,)
$$

所以我们需要定义这些模式，比如数的模式，函数的模式等等。对于简单的符号，比如括号，运算符这些，由于其形式单一，处理起来都很方便，但是对于数字这种有无限可能变化的词素，更好的方式是使用正则表达式来进行匹配。

接下来我们研究如何匹配公式中出现的数字，首先定义什么样的数字是合法的，一般来讲，有1)整数，例如 1234， 2) 浮点数，例如 123.2，3)科学计数表示，例如 1.234E10。先大致定义这么三种，然后我们就要考虑写出能够覆盖这些串的正则表达式。首先是整数的匹配，这很简单，即

$$
[0-9]+
$$

[0-9] 表示匹配任意的数字字符，后面的 + 号表示将前面的规则应用1次或多次，而整数正是有一个或者多个数字字符组成的。接下来是匹配浮点数

$$
[0-9]+(.[0-9]+)?
$$

如果用 int 来替换 [0-9]+ 可能会好理解点

$$
int(.int)?
$$

这里小括号表示里面的内容是一个整体块，后面的 ? 表示前面的块可以出现一次或者不出现，即

$$
int(.int)? = int \quad or  \quad int.int
$$

很明显，这就是一个整数或者浮点数的表达形式。最后考虑科学计数法表示的数

$$
int(.int)?([Ee][+-]?int)?
$$

这里最后的 ? 表示后面这块可以出现一次或者不出现，[Ee] 表示可以使用 E 或者 e 来表明科学计数法。

这样我们就用正则表达式把源字符串中数字的模式给表达出来了，而应用正则表达式来进行模式匹配的工作可以通过有限状态机来完成。

待续












end
