---
layout: default
---

## 问题：零钱兑换

### 问题描述与分析

感觉是一道经典的算法题，笔试面试屡试不爽。如果想把一些钱换成零钱，请问有多少兑换种方法？当然可以具体点，比如有 n 元钱，想用 k 种面额的币来兑换（k种面额可以不全部用完）。如果没有掌握一定的技巧，拿到这题是一脸蒙蔽的。首先我们需要将问题表述数学化一点：

设共有 k 中面额的纸币，分别值 $$t_i, (i = 1,,k)$$，需要兑换的钱为 n ，求总的兑换方法数量 $$S_{n,k}$$。

这道题的关键是将 $$S_{n,k}$$ 分解成两部分，一部分 $$S_{n,k-1}$$ 是将 $$n$$ 这么多钱兑换成 k - 1 种纸币的方法数量（假设不包含第 1 种纸币），其中第 1 种纸币面值 $$t_1$$，另一部分是将 $$n-t_1$$ 这么多钱兑换成 k 种纸币的方法数量 $$S_{n-t_1, k}$$，这减去的 $$t_1$$ 就表示兑换的纸币中至少包含一张 $$t_1$$ 面额的。所以第一部分表示不使用 $$t_1$$ 这种纸币的兑换方案数量，而第二部分表示一定使用了 $$t_1$$ 的数量，因此就可以得出结论 

$$
S_{n, k} = S_{n-t_1,k} + S_{n, k-1}
$$

这就将原本的问题分解成了两个较小规模的问题，可以通过递归的方式求解。现在来看看边界情况，当 $$n \le 0$$ 时，显然不存在任何兑换方案，而当 $$k = 0$$ 时，也不存在任何兑换方案。

### 代码实现

这里将求解问题的函数命名为 counting-change ，接受两个参数 n 与 k ，即需要兑换的钱的总额和零钱的种类，至于零钱的定义我们写在程序里面，假设有1，2，5，10，20，50 这几种面额的。

这里的 k 有两个作用，一是用来计量零钱的种类，二是用来获取需要排除的纸币。针对第二个作用，我们定义函数

```scheme
(define (value k)
  (cond ((= k 1) 1)
		((= k 2) 2)
		((= k 3) 5)
		((= k 4) 10)
		((= k 5) 20)
		((= k 6) 50)))
```

然后再按前面讨论的递归方案写出 counting-change

```scheme
(define (counting-change n k)
  (cond ((= n 0) 1)
		((or (= k 0) (< n 0)) 0)
		(else (+ (counting-change (- n (value k)) k)
				 (counting-change n (- k 1))))))
```

这里的参数 k 显然与 value 函数的实现挂钩，因此不允许外部调用者随意设定，可以使用下面的函数封装

```scheme
(define (count-change n)
  (counting-change n 6))
```

### 重构

虽然上述的实现确实能解决问题，但是不难发现，该算法过程有太多冗余计算，以 (count-change 6) 为例，下图展示了程序的树形递归计算过程

![](/resources/2017-10-26-sicp-example-counting-change/img.jpg)