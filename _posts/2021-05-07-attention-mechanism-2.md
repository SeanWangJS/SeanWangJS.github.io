---
title: 对注意力机制的一些理解（后篇）
tags: 循环神经网络 注意力机制
---

在上一篇文章中，不太正式地介绍了注意力机制，我们从概念上了解到注意力机制的实质是在输出每个预测单词的时候输入单词有不同的权重，本篇文章希望从算法角度来进一步解释。

<!-- ##### 语言模型

从定义上来看，语言模型指的是一个单词序列成为合法语句的概率 \\(p(x_1, x_2, ,,, x_T)\\)，根据贝叶斯公式，这个概率公式又可以写作

$$
  p(x_1, x_2,,,x_T) = p(x_1)p(x_2\mid x_1)... p(x_{T}\mid x_{T-1},,,x_1)
  $$

或者写成求积形式

$$
  p(x_1, x_2,,,x_T) = \prod_{t=1}^T p(x_t\mid x_{t-1},,, x_1)
  $$



##### 统计机器翻译

翻译的本质是将源语言的词语序列变换成目标语言的词语序列，假如有一个翻译模型 \\(\rho_{\theta}\\)，给定输入序列 \\(\mathbf{x} = x_1, x_2,,,x_T\\)，输出序列为 \\(\mathbf{y} = y_1, y_2,,, y_{T'}\\) ，从统计学上，这种情况发生的概率为

$$
  p_{\theta}(\mathbf{y}\mid \mathbf{x})
  $$

其中 \\(\theta\\) 是翻译模型的内部参数，显然不同的参数导致的概率也不同，而机器翻译要解决的问题就是找到这样的参数，使得下述对数似然函数极大

$$
  \theta = \argmax_{\theta} \frac{1} {N} \sum_{i=0}^N \log p_\theta(\mathbf{y}_i\mid \mathbf{x}_i)
  $$

其中 \\(\{(\mathbf{x}_i, \mathbf{y}_i)\mid i = 0,,, n\}\\) 为训练集。 -->

##### 基于 RNN 的 Encoder-Decoder 结构

**Kyunghyun Cho** 在论文 [Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation](https://arxiv.org/abs/1406.1078) 中提出了基于 RNN 的 Encoder-Decoder 结构，它的编码器是一个 RNN，在时刻 \\(t\\) 的隐层状态为

$$
  h_{t} = f(h_{t-1}, x_t)
  $$

其中 \\(h\\) 为隐层状态，\\(x\\) 为输入词（记住它们都是向量），将这个 RNN 在时间上展开得到如下图所示的结构

![](/resources/2021-05-07-attention-mechanism-2/attention-encoder.png)

这里的 \\(c\\) 就是最终输出向量，也就是说，编码器的作用是将源语句的所有单词编码成一个固定长度的向量。

另一方面，解码器也是一个 RNN，它在时间上展开如下图所示

![](/resources/2021-05-07-attention-mechanism-2/attention-decoder.png)

可以看到，每个时刻的隐层状态都依赖于上一个时刻的隐层状态、上一个输出词以及输入序列编码 \\(c\\)，于是在时刻 \\(t\\) 的隐层状态可以表示为

$$
  h'_t = f(h'_{t-1}, y_{t-1}, c)
  $$

而输出词则为 

$$
  y_t = g(h'_t, y_{t-1}, c)
  $$

##### 引入注意力机制后的 Encoder-Decoder 结构

上一节的 Decoder 在计算所有 \\(y_t\\)的时候，所依赖的 \\(c\\) 都是相同的，也就是说，同一个输入序列编码被用于解码所有输出单词。这一特点导致生成输出序列的每个词的时候，输入单词所占的权重没有任何变化，显然，这与常识不符。为了改进这个缺陷，**Dzmitry Bahdanau** 在论文 [Neural Machine Translation by Jointly Learning to Align and Translate](https://arxiv.org/abs/1409.0473) 中提出了新的想法，即令 \\(y_t\\) 依赖于变化的 \\(c\\)

$$
  h'_t = f(h'_{t-1}, y_{t-1}, c_t)\\
  y_t = g(h'_t, y_{t-1}, c_t) 
  $$

这时我们把解码器的图像表示稍微修改一下以阐述这种思想

![](/resources/2021-05-07-attention-mechanism-2/attention-decoder-2.png)

这里的 \\(c_t\\) 则是编码器隐层状态的加权和

$$
  c_t = \sum_{i = 1}^T \alpha_{ti} h_i
  $$

显然，输入单词对输出单词的不同影响可以通过调整权重来体现。这时编码器的结构可以修改为下图

![](/resources/2021-05-07-attention-mechanism-2/attention-encoder-2.png)

所以 \\(c_t\\) 向量决定了在预测输出单词 \\(y_t\\) 的时候，哪些输入单词应该被重点关注，这就是注意力的含义，所以 \\(c_t\\) 也可以被称为注意力向量。

接下来讨论权重矩阵 \\(\alpha\\)，依我们最直接的想法，可以把这个权重矩阵作为神经网络自身的参数进行训练，但是马上就可以发现这一思路不可行，一个原因是神经网络的参数是固定的，而不同的语句，其注意力模型显然是不一样的，固定的权重显然无法实现这一目标，另一个原因是不同语句的单词序列长度一般也不一样，固定大小的权重矩阵显然也不好处理。

所以在这篇论文中引入了对齐模型(alignment model)的概念，简单来说，对齐模型的目的是为了计算第 \\(i\\) 个输入单词所处的语义环境和第 \\(j\\) 个输出单词所处的语义环境的匹配程度。这里的语义环境其实就是隐层状态，因为它是对单词序列的编码，所以包含了当前单词及其环境的语义信息。

其实关于这一点我们还可以多说几句，在上述的编码器结构中，隐层状态实际上只包含了当前单词及其之前单词的语义信息，所以这里的语义信息不是很完整，而为了补充后面单词的语义信息，论文改进了编码器结构，采用双向 RNN，如下图所示

![](/resources/2021-05-07-attention-mechanism-2/attention-encoder-3.png)

使用这种结构，\\(\vec{h}_t\\) 包含当前单词及其左边的语义信息，\\(\leftarrow{h}_t\\) 包含当前单词及其右边的语义信息，于是它们的组合 \\(h_t\\) 就完整地包含了当前单词的语义信息。

于是在编码器端，\\(h_i\\) 代表第 \\(i\\) 个单词的语义环境，而在解码器端，本来应该是 \\(h'_j\\) 来代表第 \\(j\\) 个单词的语义环境，但是 \\(h'_j\\) 本身又依赖于 \\(c_j\\)，为了不造成循环依赖，我们只有退而求其次地使用 \\(h'_{j-1}\\) 来代表第 \\(j\\) 个输出单词的语义环境，两者之间相差一个单词位置，所以这种替换问题不大。

定义了输入输出单词的语义环境表示之后，就可以回来定义之前提到的对齐模型了，对齐模型以第 \\(i\\) 个 输入单词的语义环境信息和第 \\(j\\) 个输出单词的语义环境信息为参数，返回一个量化的输入输出匹配值，即 

$$
  e_{ji} = a(h_i, h'_{j-1})
  $$

然后再对 \\(e_{ij}\\) 作 softmax 归一化变换，得到我们刚才提到的权重矩阵 

$$
  \alpha_{ji} = \frac{\exp(e_{ij})}{\sum_{k = 1}^T \exp(e_{jk})}
  $$

这样一来，将对齐模型 \\(a\\) 神经网络化并参与模型训练过程，就能解决权重矩阵 \\(\alpha\\) 的获取问题了。

##### 总结
本文主要介绍了 Kyunghyun Cho 和 Dzmitry Bahdanau 两篇论文的主要想法，简单地说，Kyunghyun Cho 提出了基于 Encoder-Decoder 的机器翻译模型结构，而 Bahdanau 则在此基础上引入了注意力机制，以及与之相关的对齐模型。本文还尝试解释了 Bahdanau 使用双向 RNN 结构的原因，即为了获取更完整的语义从而更好地利用对齐模型。