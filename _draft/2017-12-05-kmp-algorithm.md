---
layout: default
---

## 字符串匹配的 KMP (Knuth-Morris-Pratt) 算法

考虑在文本 text 中寻找特定的字符串 str，最直观的想法是，从文本的第一个字符开始逐个搜索匹配，一旦遇到不一样的字符，则中断，然后从第二个文本字符开始，重复这一过程，直到完全匹配上字符串为止，如下图所示。

![](/resources/2017-12-05-kmp-algorithm/anime.gif)

下面来计算一下上述算法的时间复杂度，假设文本长度为 n ，匹配字符串的长度为 m，伪码如下

```ruby
for i = 0 -> n-m
  matched = true;
  for j = 0 -> m
    if text[i + j] != str[j]
      matched = false;
      break
    end
  end  
  if matched
    break with "message: matched at " + i
  end
end
```

算法有内外层循环，我们假设目标字符串的第一个字符位于文本 text 中的第 k 个位置，那么外层循环将执行 k 次。而内层循环的判断次数实际上是两个字符串 text[i:i+m] 和 str 的相同前缀长度加一，这里假设为 t。于是该算法总的判断次数应该是 kt。显然由于随机性，k 与 t 的具体值我们不可能知道，但是可以利用概率论的方法确定 k 和 t 的期望，然后算出其时间复杂度的量级。

一个长为 n 的文本，包含一个长为 m 的字符串，如果位置完全随机，那么字符串出现在任何位置的概率为 $\frac {1}{n - m + 1}$ ，从而

\[
E[k] = \sum_{i=1}^{n-m+1} \frac{i}{n - m + 1} = \frac{n-m+2}{2}
\]

而对 t 的估计，其实就是计算两个长度为 m 的字符串的相同前缀长度的期望，这就涉及到字符集的问题，我们假设所用的字符集的大小为 L，现在来计算前缀长度的概率。

t = 1 时，注意 t 是字符比较次数，只比较一次，意味着两个串的第一个字符就不一样，其中一个串的第一个字符有 L 种选择，那么另一个就只能从剩下的 L - 1 个字符中选择了，这样两个串的第一个字符不同的组合方式有 $L(L-1)$ 种，而两个字符的总的组合方式有 $L^2$ 种，所以 t = 1 的概率为

\[
p(t=1) = \frac{L-1}{L}
\]

t = 2 时，两个串的第一个字符相同，它们可以是 L 种字符中的一个，第二个字符不一样，又有 $L(L-1)$ 种组合，而总的组合方式有 $L^4$ 种，于是

\[
p(t=2) = \frac{L L (L-1)}{L^4} = \frac{L-1}{L^2}
\]

以此类推，可以得到概率序列

\[
p(t=i) = \frac{L-1}{L^{i}},\quad i \in\{1,,,m\}
\]

于是

\[
E[t] = \sum_{i=1}^{m} i p(t=i) = \sum_{i=1}^{m} \frac{i(L-1)}{L^{i}}
\]

可以大致计算下，对于较大的 L ， $E[t]$ 基本上等于 1，对于较小的 L ，$E[t]$ 也会收敛到 2。

而 k 与 t 的取值显然是独立的，于是比较次数的期望就大致为

\[
E[kt] \approx \frac{n-m+2}{2}
\]

所以该算法的平均时间复杂度为 $O(n-m)$。看起来还不错，但如果我们修改下需求，要在文本种找到所有符合条件的字符串，此时 $k=n-m$。







end
