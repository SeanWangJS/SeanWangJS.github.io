---
title: 使用位运算来模拟加减乘除
tags: 位运算
---

##### 加法

分析：
十进制的加法运算可以拆分为三个步骤：
1. 不进位求和，示例 \(3453 + 9873 = 2226\)；
2. 仅计算进位，示例 \(3453 + 9873 = 11100\)；
3. 前两步的结果求和，示例 \(3453 + 9873 = 2226 + 11100 = 13326\)。

同样的地，二进制加法也可以分解为同样的形式，以 \(18+15\) 为例，它的二进制形式为 \(10010 + 1111\)
1. 10010 + 1111 = 11101
2. 10010 + 1111 = 00100
3. 11101 + 00100 = 100001

对于二进制数据来说，第一步相当于异或运算，第二步相当于与运算后接左移一位，而第三步也是加法运算，假如我们实现了这种加法，那么第三步可以递归地调用该方法。

实现：

```java
int add(int a, int b) {

  if(b == 0) {
            return a;
  }
  int c = a ^ b;
  int d = (a & b) << 1;
  return add(c, d);        

}
```

##### 减法

分析：实现了加法操作，只需要将第二个操作数变成负数即可实现减法，但由于不能出现负号，所以采用补码加一的方式实现负数。

实现：

```java

int sub(int a, int b) {
  return add(a, add(~b, 1));
}

```

##### 乘法

分析：乘法的本质上也可以用加法实现，比如整数 \(abcd\) 乘以 \(efgh\)，相当于 \(efgh\) 次 \(abcd\) 与自身相加，但是这样实现的复杂度太高。另一方面，我们将乘法分解成下述形式

\[
  abcd\times efgh = abcd \times e \times 1000 + abcd \times f \times 100 + abcd \times g \times 10 + abcd \times h
  \]

上述的 \(\times 1000,\times 100, \times 10\) 这些操作可以通过移位实现，于是真正需要的加法操作就只有 \(e + f+ g+ h\) 次，这种方式大大降低了复杂度。

对于二进制乘法，原理是类似的，只不过这时的 \(a,b,c,d,e,f,g,h\) 都是 0 或 1，于是可以按下述方式做分解 

\[
  10111011 \times 1101 = 10111011 \ll 3 + 10111011 \ll 2 + 10111011
  \]

也就是说，乘数的二进制表示上，如果第 \(n\) 位等于 1，则将被乘数左移 \(n-1\)位，并加入求和，最终得到的结果就是乘法结果。

为了编程的方便，我们可以把上述过程改成递归的形式，即

\[
  \begin{aligned}
  & 10111011 \times 1101 = 10111011 \times 1100 + 10111011\\
  & 10111011 \times 1100 = 10111011 \times 1000 + 10111011 \ll 2\\
  & 10111011 \times 1000 = 10111011 \ll 3
  \end{aligned}
  \]


